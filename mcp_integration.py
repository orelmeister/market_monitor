"""
mcp_integration.py — MCP Server Integration for Market Monitor Agent

This module provides integration with Model Context Protocol (MCP) servers
for extended capabilities:

  - GitHub: Repository management, issue tracking, code search
  - Memory: Persistent knowledge storage for pattern recognition
  - Fetch: Web data fetching from financial news sources
  - Sequential Thinking: Complex multi-step market analysis
  - Filesystem: Local data storage for reports and history

The MCP integration allows the agent to:
  1. Access external data sources beyond API providers
  2. Maintain persistent memory across sessions
  3. Collaborate through GitHub for strategy development
  4. Perform complex reasoning for market analysis
"""

import json
import logging
import os
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Callable, Optional, Union
from zoneinfo import ZoneInfo

logger = logging.getLogger(__name__)


# ═══════════════════════════════════════════════════════════════════════════════
# MCP TOOL INTERFACES
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class MCPToolCall:
    """Represents a call to an MCP tool."""
    server: str
    tool: str
    arguments: dict[str, Any]
    timeout_ms: int = 30000


@dataclass  
class MCPToolResult:
    """Result from an MCP tool call."""
    success: bool
    data: Any
    error: Optional[str] = None
    execution_time_ms: float = 0.0


class MCPServerInterface(ABC):
    """Abstract interface for MCP server interactions."""
    
    @abstractmethod
    async def call_tool(self, tool: str, arguments: dict) -> MCPToolResult:
        """Call a tool on the MCP server."""
        pass
    
    @abstractmethod
    def list_tools(self) -> list[str]:
        """List available tools on this server."""
        pass


# ═══════════════════════════════════════════════════════════════════════════════
# GITHUB MCP INTEGRATION
# ═══════════════════════════════════════════════════════════════════════════════

class GitHubMCPTools:
    """Tools for GitHub MCP server integration."""
    
    # Market monitoring-relevant GitHub tools
    AVAILABLE_TOOLS = [
        "github_search_code",
        "github_search_issues",
        "github_search_repositories",
        "github_get_file_contents",
        "github_create_issue",
        "github_add_issue_comment",
        "github_list_issues",
        "github_create_pull_request",
        "github_get_me",
    ]
    
    @staticmethod
    def get_tool_definitions() -> list[dict]:
        """Get tool definitions for the agent."""
        return [
            {
                "name": "github_search_market_tools",
                "description": "Search GitHub for market analysis tools and strategies",
                "mcp_tool": "github_search_code",
                "default_args": {"query": "market analysis python"},
            },
            {
                "name": "github_create_market_event",
                "description": "Create a GitHub issue to track a significant market event",
                "mcp_tool": "github_create_issue",
                "template": {
                    "title": "[MARKET EVENT] {event_type}: {summary}",
                    "body": "## Market Event\n\n**Type**: {event_type}\n**Date**: {date}\n**Impact**: {impact}\n\n### Details\n{details}\n\n### Action Items\n- [ ] Analyze impact\n- [ ] Update strategy\n- [ ] Monitor follow-up",
                    "labels": ["market-event", "automated"],
                },
            },
            {
                "name": "github_track_strategy_change",
                "description": "Document a strategy change in the repository",
                "mcp_tool": "github_push_files",
                "template": {
                    "path": "strategy_log/{date}_strategy_update.md",
                    "content": "# Strategy Update: {date}\n\n## Trigger\n{trigger}\n\n## Changes\n{changes}\n\n## Expected Outcome\n{outcome}",
                },
            },
        ]
    
    @staticmethod
    def format_market_event_issue(
        event_type: str,
        summary: str,
        details: str,
        impact: str = "Unknown"
    ) -> dict:
        """Format a market event for GitHub issue creation."""
        date = datetime.now(ZoneInfo("US/Eastern")).strftime("%Y-%m-%d %H:%M %Z")
        
        return {
            "title": f"[MARKET EVENT] {event_type}: {summary}",
            "body": f"""## Market Event

**Type**: {event_type}
**Date**: {date}
**Impact Level**: {impact}

### Summary
{summary}

### Details
{details}

### Analysis Required
- [ ] Assess portfolio impact
- [ ] Review technical indicators
- [ ] Check macro conditions
- [ ] Update strategy if needed

---
*Automatically generated by Market Monitor Agent*
""",
            "labels": ["market-event", "automated", event_type.lower().replace(" ", "-")],
        }


# ═══════════════════════════════════════════════════════════════════════════════
# MEMORY MCP INTEGRATION
# ═══════════════════════════════════════════════════════════════════════════════

class MemoryMCPTools:
    """Tools for Memory MCP server integration."""
    
    AVAILABLE_TOOLS = [
        "create_entities",
        "add_observations",
        "create_relations",
        "search_nodes",
        "read_graph",
        "open_nodes",
        "delete_entities",
        "delete_observations",
        "delete_relations",
    ]
    
    @staticmethod
    def get_entity_templates() -> dict[str, dict]:
        """Get entity templates for market monitoring."""
        return {
            "MarketSignal": {
                "type": "MarketSignal",
                "properties": ["name", "level", "timestamp", "ticker", "value"],
                "description": "A signal generated by market analysis",
            },
            "MarketEvent": {
                "type": "MarketEvent", 
                "properties": ["date", "event_type", "impact", "description"],
                "description": "A significant market event",
            },
            "StrategyChange": {
                "type": "StrategyChange",
                "properties": ["date", "trigger", "from_state", "to_state", "reasoning"],
                "description": "A change in investment strategy",
            },
            "Pattern": {
                "type": "Pattern",
                "properties": ["name", "occurrences", "reliability", "description"],
                "description": "A recognized market pattern",
            },
            "Asset": {
                "type": "Asset",
                "properties": ["ticker", "asset_class", "role", "current_allocation"],
                "description": "A monitored financial asset",
            },
        }
    
    @staticmethod
    def format_signal_entity(signal: dict) -> dict:
        """Format a market signal for memory storage."""
        return {
            "name": f"Signal_{signal.get('name', 'Unknown')}_{datetime.now().strftime('%Y%m%d_%H%M')}",
            "entityType": "MarketSignal",
            "observations": [
                f"Level: {signal.get('level', 'INFO')}",
                f"Message: {signal.get('message', 'No message')}",
                f"Value: {signal.get('value', 'N/A')}",
                f"Timestamp: {datetime.now(ZoneInfo('US/Eastern')).isoformat()}",
            ],
        }
    
    @staticmethod
    def format_pattern_entity(pattern_name: str, observations: list[str]) -> dict:
        """Format a pattern for memory storage."""
        return {
            "name": f"Pattern_{pattern_name}",
            "entityType": "Pattern",
            "observations": observations,
        }
    
    @staticmethod
    def get_relation_types() -> list[dict]:
        """Get relation types for market knowledge graph."""
        return [
            {"name": "TRIGGERS", "from": "MarketEvent", "to": "MarketSignal"},
            {"name": "LEADS_TO", "from": "MarketSignal", "to": "StrategyChange"},
            {"name": "AFFECTS", "from": "MarketEvent", "to": "Asset"},
            {"name": "CORRELATES_WITH", "from": "Asset", "to": "Asset"},
            {"name": "PRECEDES", "from": "Pattern", "to": "MarketEvent"},
            {"name": "INDICATES", "from": "Pattern", "to": "MarketSignal"},
        ]


# ═══════════════════════════════════════════════════════════════════════════════
# FETCH MCP INTEGRATION  
# ═══════════════════════════════════════════════════════════════════════════════

class FetchMCPTools:
    """Tools for Fetch MCP server integration."""
    
    # Financial news sources
    NEWS_SOURCES = {
        "marketwatch": "https://www.marketwatch.com/latest-news",
        "reuters_markets": "https://www.reuters.com/markets/",
        "bloomberg": "https://www.bloomberg.com/markets",
        "cnbc": "https://www.cnbc.com/world-markets/",
        "yahoo_finance": "https://finance.yahoo.com/",
        "fed_news": "https://www.federalreserve.gov/newsevents.htm",
        "sec_filings": "https://www.sec.gov/cgi-bin/browse-edgar?action=getcurrent",
    }
    
    # Specific data sources
    DATA_SOURCES = {
        "earnings_calendar": "https://finance.yahoo.com/calendar/earnings",
        "economic_calendar": "https://www.investing.com/economic-calendar/",
        "fed_calendar": "https://www.federalreserve.gov/monetarypolicy/fomccalendars.htm",
        "vix": "https://finance.yahoo.com/quote/%5EVIX",
        "fear_greed": "https://edition.cnn.com/markets/fear-and-greed",
    }
    
    @staticmethod
    def get_fetch_targets() -> list[dict]:
        """Get recommended fetch targets for market monitoring."""
        return [
            {
                "name": "market_news",
                "urls": [
                    FetchMCPTools.NEWS_SOURCES["marketwatch"],
                    FetchMCPTools.NEWS_SOURCES["reuters_markets"],
                ],
                "frequency": "hourly",
                "purpose": "General market news sentiment",
            },
            {
                "name": "fed_watch",
                "urls": [
                    FetchMCPTools.NEWS_SOURCES["fed_news"],
                    FetchMCPTools.DATA_SOURCES["fed_calendar"],
                ],
                "frequency": "daily",
                "purpose": "Federal Reserve announcements and calendar",
            },
            {
                "name": "volatility_indicators",
                "urls": [
                    FetchMCPTools.DATA_SOURCES["vix"],
                    FetchMCPTools.DATA_SOURCES["fear_greed"],
                ],
                "frequency": "every_4_hours",
                "purpose": "Market volatility and sentiment indicators",
            },
            {
                "name": "earnings_events",
                "urls": [
                    FetchMCPTools.DATA_SOURCES["earnings_calendar"],
                ],
                "frequency": "daily",
                "purpose": "Upcoming earnings that may impact holdings",
            },
        ]


# ═══════════════════════════════════════════════════════════════════════════════
# SEQUENTIAL THINKING MCP INTEGRATION
# ═══════════════════════════════════════════════════════════════════════════════

class SequentialThinkingMCPTools:
    """Tools for Sequential Thinking MCP server integration."""
    
    @staticmethod
    def get_analysis_templates() -> list[dict]:
        """Get thinking templates for market analysis."""
        return [
            {
                "name": "market_crash_assessment",
                "description": "Step-by-step assessment of potential market crash",
                "steps": [
                    "Analyze current technical indicators (SMA, RSI, volume)",
                    "Review recent macro signals (news sentiment, Fed policy)",
                    "Check crypto canary indicators (BTC correlation)",
                    "Assess historical precedents for similar conditions",
                    "Evaluate portfolio exposure and risk",
                    "Formulate action recommendation with confidence level",
                ],
            },
            {
                "name": "recovery_evaluation",
                "description": "Evaluate market recovery signals",
                "steps": [
                    "Confirm technical crossover above key levels",
                    "Check for improving breadth (advance/decline)",
                    "Verify macro conditions support recovery",
                    "Assess whether recovery is sustainable",
                    "Determine optimal re-entry timing",
                    "Plan position sizing for recovery phase",
                ],
            },
            {
                "name": "portfolio_rebalance_decision",
                "description": "Decide on portfolio rebalancing",
                "steps": [
                    "Review current allocation vs. target",
                    "Analyze recent performance deviation",
                    "Consider tax implications of trades",
                    "Factor in current market regime",
                    "Calculate optimal trade sizes",
                    "Prioritize trades by impact and cost",
                ],
            },
            {
                "name": "signal_conflict_resolution",
                "description": "Resolve conflicting market signals",
                "steps": [
                    "List all current signals and their levels",
                    "Categorize by signal type (technical vs. macro)",
                    "Weight signals by historical reliability",
                    "Identify potential false positives",
                    "Determine dominant signal direction",
                    "Recommend action with uncertainty acknowledgment",
                ],
            },
        ]
    
    @staticmethod
    def format_thinking_prompt(template_name: str, context: dict) -> str:
        """Format a thinking prompt for the sequential thinking server."""
        templates = {
            "market_crash_assessment": """
Assess whether current market conditions indicate an imminent crash.

Context:
- SPY Price: ${spy_price} (SMA-200: ${spy_sma})
- SPY RSI: {spy_rsi}
- BTC 24h Change: {btc_change}%
- News Sentiment: {news_sentiment}
- VIX Level: {vix}

Walk through your analysis step by step, considering:
1. How do technical indicators compare to crash precedents?
2. Are macro conditions supportive or threatening?
3. What does the crypto market signal?
4. What is the probability of a significant drawdown?
5. What specific actions should be taken?
""",
            "recovery_evaluation": """
Evaluate whether current signals indicate a sustainable market recovery.

Context:
- SPY just crossed above 200-SMA
- Previous regime: {previous_regime}
- Days in bear market: {bear_days}
- Current RSI: {rsi}
- Macro environment: {macro_status}

Analyze step by step:
1. Is this a genuine regime change or a bear trap?
2. What historical recoveries share similar characteristics?
3. What confirmation signals should we wait for?
4. What is the recommended re-entry approach?
""",
        }
        
        template = templates.get(template_name, "Analyze the following market situation: {context}")
        return template.format(**context)


# ═══════════════════════════════════════════════════════════════════════════════
# MCP COORDINATOR
# ═══════════════════════════════════════════════════════════════════════════════

class MCPCoordinator:
    """
    Coordinates all MCP server interactions for the Market Monitor Agent.
    
    This class provides a unified interface for:
    - Calling tools across different MCP servers
    - Managing server connections
    - Handling errors and retries
    - Logging MCP interactions
    """
    
    def __init__(self, config_path: str = "mcp_config.json"):
        self.config_path = config_path
        self.config = self._load_config()
        self._connection_status: dict[str, bool] = {}
        logger.info(f"MCP Coordinator initialized with {len(self.config.get('mcpServers', {}))} servers")
    
    def _load_config(self) -> dict:
        """Load MCP configuration from file."""
        try:
            if os.path.exists(self.config_path):
                with open(self.config_path, "r") as f:
                    return json.load(f)
        except Exception as e:
            logger.warning(f"Could not load MCP config: {e}")
        return {"mcpServers": {}}
    
    def list_servers(self) -> list[dict]:
        """List all configured MCP servers."""
        servers = []
        for name, config in self.config.get("mcpServers", {}).items():
            servers.append({
                "name": name,
                "description": config.get("description", "No description"),
                "capabilities": config.get("capabilities", []),
            })
        return servers
    
    def get_server_tools(self, server_name: str) -> list[str]:
        """Get available tools for a specific server."""
        tool_map = {
            "github": GitHubMCPTools.AVAILABLE_TOOLS,
            "memory": MemoryMCPTools.AVAILABLE_TOOLS,
            "fetch": ["fetch_webpage"],
            "sequential-thinking": ["sequentialthinking"],
            "filesystem": ["read_file", "write_file", "list_directory"],
        }
        return tool_map.get(server_name, [])
    
    def get_all_available_tools(self) -> dict[str, list[str]]:
        """Get all available tools across all servers."""
        return {
            server: self.get_server_tools(server)
            for server in self.config.get("mcpServers", {}).keys()
        }
    
    async def execute_mcp_tool(self, call: MCPToolCall) -> MCPToolResult:
        """
        Execute an MCP tool call.
        
        Note: This is a placeholder that would integrate with actual MCP runtime.
        In production, this would use the MCP client library.
        """
        logger.info(f"MCP Tool Call: {call.server}/{call.tool} with args: {call.arguments}")
        
        # Placeholder - actual implementation would use MCP client
        return MCPToolResult(
            success=True,
            data={
                "message": f"MCP tool call simulated: {call.server}/{call.tool}",
                "arguments": call.arguments,
                "note": "Configure MCP servers in VS Code settings for actual execution",
            },
        )
    
    def get_recommended_mcp_actions(self, signal: dict) -> list[dict]:
        """
        Get recommended MCP actions based on a market signal.
        
        This maps market conditions to useful MCP tool calls.
        """
        actions = []
        signal_level = signal.get("level", "INFO")
        signal_name = signal.get("name", "")
        
        # Always store signals in memory
        actions.append({
            "server": "memory",
            "tool": "add_observations",
            "purpose": "Store signal in knowledge graph",
            "arguments": MemoryMCPTools.format_signal_entity(signal),
        })
        
        # Critical signals: Create GitHub issue for tracking
        if signal_level == "CRITICAL":
            actions.append({
                "server": "github",
                "tool": "github_create_issue",
                "purpose": "Track critical market event",
                "arguments": GitHubMCPTools.format_market_event_issue(
                    event_type=signal_name,
                    summary=signal.get("message", "")[:100],
                    details=signal.get("message", ""),
                    impact="High",
                ),
            })
        
        # News-related signals: Fetch additional news
        if "NEWS" in signal_name:
            actions.append({
                "server": "fetch",
                "tool": "fetch_webpage",
                "purpose": "Get additional news context",
                "arguments": {
                    "url": FetchMCPTools.NEWS_SOURCES["reuters_markets"],
                },
            })
        
        # Complex signals: Use sequential thinking
        if signal_level in ["CRITICAL", "WARNING"] and "CROSS" in signal_name:
            actions.append({
                "server": "sequential-thinking",
                "tool": "sequentialthinking",
                "purpose": "Deep analysis of market regime change",
                "arguments": {
                    "thought": SequentialThinkingMCPTools.format_thinking_prompt(
                        "market_crash_assessment" if "BELOW" in signal_name else "recovery_evaluation",
                        {"context": signal},
                    ),
                },
            })
        
        return actions


# ═══════════════════════════════════════════════════════════════════════════════
# EXPORTS
# ═══════════════════════════════════════════════════════════════════════════════

__all__ = [
    "MCPToolCall",
    "MCPToolResult",
    "MCPServerInterface",
    "GitHubMCPTools",
    "MemoryMCPTools",
    "FetchMCPTools",
    "SequentialThinkingMCPTools",
    "MCPCoordinator",
]
